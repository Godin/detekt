<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Signatures.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.api.internal</a> &gt; <span class="el_source">Signatures.kt</span></div><h1>Signatures.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.api.internal

import org.jetbrains.kotlin.asJava.namedUnwrappedElement
import org.jetbrains.kotlin.com.intellij.psi.PsiElement
import org.jetbrains.kotlin.psi.KtClassOrObject
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.psiUtil.endOffset
import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
import org.jetbrains.kotlin.psi.psiUtil.parents
import org.jetbrains.kotlin.psi.psiUtil.startOffset
import org.jetbrains.kotlin.psi.psiUtil.startOffsetSkippingComments

<span class="fc" id="L14">private val multipleWhitespaces = Regex(&quot;\\s{2,}&quot;)</span>

<span class="pc bpc" id="L16" title="1 of 4 branches missed.">internal fun PsiElement.searchName(): String = this.namedUnwrappedElement?.name ?: &quot;&lt;UnknownName&gt;&quot;</span>

/*
 * KtCompiler wrongly used Path.filename as the name for a KtFile instead of the whole path.
 * This resulted into the question &quot;How do we get the absolute path from a KtFile?&quot;.
 * Fixing this problem, we do not need KtFile.absolutePath anymore.
 *
 * Fixing the filename will change all baseline signatures.
 * Therefore we patch the signature here to restore the old behavior.
 *
 * Fixing the baseline will need a new major release - #2680.
 */
internal fun PsiElement.buildFullSignature(): String {
<span class="fc" id="L29">    var fullSignature = this.searchSignature()</span>
<span class="fc" id="L30">    val parentSignatures = this.parents</span>
<span class="fc" id="L31">        .filter { it is KtClassOrObject }</span>
<span class="fc" id="L32">        .map { it.extractClassName() }</span>
<span class="fc" id="L33">        .toList()</span>
<span class="fc" id="L34">        .reversed()</span>
<span class="fc" id="L35">        .joinToString(&quot;.&quot;)</span>

<span class="fc bfc" id="L37" title="All 4 branches covered.">    if (parentSignatures.isNotEmpty()) {</span>
<span class="fc" id="L38">        fullSignature = &quot;$parentSignatures\$$fullSignature&quot;</span>
    }

<span class="fc" id="L41">    val filename = this.containingFile.name</span>
<span class="pc bpc" id="L42" title="1 of 2 branches missed.">    if (!fullSignature.startsWith(filename)) {</span>
<span class="fc" id="L43">        fullSignature = &quot;$filename\$$fullSignature&quot;</span>
    }

<span class="fc" id="L46">    return fullSignature</span>
}

private fun PsiElement.extractClassName() =
<span class="pc bpc" id="L50" title="3 of 6 branches missed.">    this.getNonStrictParentOfType&lt;KtClassOrObject&gt;()?.nameAsSafeName?.asString().orEmpty()</span>

private fun PsiElement.searchSignature(): String =
<span class="fc" id="L53">    when (this) {</span>
<span class="fc bfc" id="L54" title="All 2 branches covered.">        is KtNamedFunction -&gt; buildFunctionSignature(this)</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">        is KtClassOrObject -&gt; buildClassSignature(this)</span>
<span class="fc bfc" id="L56" title="All 2 branches covered.">        is KtFile -&gt; fileSignature()</span>
<span class="fc" id="L57">        else -&gt; this.text</span>
<span class="fc" id="L58">    }.replace('\n', ' ').replace(multipleWhitespaces, &quot; &quot;)</span>

<span class="fc" id="L60">private fun KtFile.fileSignature() = &quot;${this.packageFqName.asString()}.${this.name}&quot;</span>

private fun buildClassSignature(classOrObject: KtClassOrObject): String {
<span class="fc" id="L63">    var baseName = classOrObject.nameAsSafeName.asString()</span>
<span class="fc" id="L64">    val typeParameters = classOrObject.typeParameters</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">    if (typeParameters.size &gt; 0) {</span>
<span class="fc" id="L66">        baseName += &quot;&lt;&quot;</span>
<span class="fc" id="L67">        baseName += typeParameters.joinToString(&quot;, &quot;) { it.text }</span>
<span class="fc" id="L68">        baseName += &quot;&gt;&quot;</span>
    }
<span class="fc" id="L70">    val extendedEntries = classOrObject.superTypeListEntries</span>
<span class="fc bfc" id="L71" title="All 4 branches covered.">    if (extendedEntries.isNotEmpty()) baseName += &quot; : &quot;</span>
<span class="pc bpc" id="L72" title="2 of 4 branches missed.">    extendedEntries.forEach { baseName += it.typeAsUserType?.referencedName.orEmpty() }</span>
<span class="fc" id="L73">    return baseName</span>
}

private fun buildFunctionSignature(element: KtNamedFunction): String {
<span class="fc" id="L77">    val startOffset = element.startOffsetSkippingComments - element.startOffset</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">    val endOffset = if (element.typeReference != null) {</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        element.typeReference?.endOffset ?: 0</span>
    } else {
<span class="fc bfc" id="L81" title="All 2 branches covered.">        element.valueParameterList?.endOffset ?: 0</span>
<span class="fc" id="L82">    } - element.startOffset</span>

<span class="fc bfc" id="L84" title="All 4 branches covered.">    require(startOffset &lt; endOffset) {</span>
<span class="fc" id="L85">        &quot;Error building function signature with range $startOffset - $endOffset for element: ${element.text}&quot;</span>
    }
<span class="fc" id="L87">    return element.text.substring(startOffset, endOffset)</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>