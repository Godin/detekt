<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CyclomaticComplexMethod.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.complexity</a> &gt; <span class="el_source">CyclomaticComplexMethod.kt</span></div><h1>CyclomaticComplexMethod.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.complexity

import io.github.detekt.metrics.CyclomaticComplexity
import io.gitlab.arturbosch.detekt.api.ActiveByDefault
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Configuration
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.config
import org.jetbrains.kotlin.psi.KtBlockExpression
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtReturnExpression
import org.jetbrains.kotlin.psi.KtWhenExpression

/**
 * Complex methods are hard to understand and read. It might not be obvious what side-effects a complex method has.
 * Prefer splitting up complex methods into smaller methods that are in turn easier to understand.
 * Smaller methods can also be named much clearer which leads to improved readability of the code.
 *
 * This rule uses McCabe's Cyclomatic Complexity (MCC) metric to measure the number of
 * linearly independent paths through a function's source code (https://www.ndepend.com/docs/code-metrics#CC).
 * The higher the number of independent paths, the more complex a method is.
 * Complex methods use too many of the following statements.
 * Each one of them adds one to the complexity count.
 *
 * - __Conditional statements__ - `if`, `else if`, `when`
 * - __Jump statements__ - `continue`, `break`
 * - __Loops__ - `for`, `while`, `do-while`, `forEach`
 * - __Operators__ `&amp;&amp;`, `||`, `?:`
 * - __Exceptions__ - `catch`, `use`
 * - __Scope Functions__ - `let`, `run`, `with`, `apply`, and `also` -&gt;
 *  [Reference](https://kotlinlang.org/docs/scope-functions.html)
 */
@ActiveByDefault(since = &quot;1.0.0&quot;)
<span class="fc" id="L36">class CyclomaticComplexMethod(config: Config) : Rule(</span>
<span class="fc" id="L37">    config,</span>
<span class="fc" id="L38">    &quot;Prefer splitting up complex methods into smaller, easier to test methods.&quot;</span>
) {

    @Configuration(&quot;The maximum allowed McCabe's Cyclomatic Complexity (MCC) for a method.&quot;)
<span class="fc" id="L42">    private val allowedComplexity: Int by config(defaultValue = 14)</span>

    @Configuration(&quot;Ignores a complex method if it only contains a single when expression.&quot;)
<span class="fc" id="L45">    private val ignoreSingleWhenExpression: Boolean by config(false)</span>

    @Configuration(&quot;Whether to ignore simple (braceless) when entries.&quot;)
<span class="fc" id="L48">    private val ignoreSimpleWhenEntries: Boolean by config(false)</span>

    @Configuration(&quot;Whether to ignore functions which are often used instead of an `if` or `for` statement.&quot;)
<span class="fc" id="L51">    private val ignoreNestingFunctions: Boolean by config(false)</span>

    @Configuration(&quot;Whether to ignore local functions and count them as one&quot;)
<span class="fc" id="L54">    private val ignoreLocalFunctions: Boolean by config(false)</span>

    @Configuration(&quot;Comma separated list of function names which add complexity.&quot;)
<span class="fc" id="L57">    private val nestingFunctions: Set&lt;String&gt; by config(DEFAULT_NESTING_FUNCTIONS) { it.toSet() }</span>

    override fun visitNamedFunction(function: KtNamedFunction) {
<span class="fc bfc" id="L60" title="All 4 branches covered.">        if (ignoreSingleWhenExpression &amp;&amp; hasSingleWhenExpression(function.bodyExpression)) {</span>
<span class="fc" id="L61">            return</span>
        }

<span class="fc" id="L64">        val complexity = CyclomaticComplexity.calculate(function) {</span>
<span class="fc" id="L65">            this.ignoreSimpleWhenEntries = this@CyclomaticComplexMethod.ignoreSimpleWhenEntries</span>
<span class="fc" id="L66">            this.ignoreNestingFunctions = this@CyclomaticComplexMethod.ignoreNestingFunctions</span>
<span class="fc" id="L67">            this.ignoreLocalFunctions = this@CyclomaticComplexMethod.ignoreLocalFunctions</span>
<span class="fc" id="L68">            this.nestingFunctions = this@CyclomaticComplexMethod.nestingFunctions</span>
<span class="fc" id="L69">        }</span>

<span class="fc bfc" id="L71" title="All 2 branches covered.">        if (complexity &gt; allowedComplexity) {</span>
<span class="fc" id="L72">            report(</span>
<span class="fc" id="L73">                ThresholdedCodeSmell(</span>
<span class="fc" id="L74">                    Entity.atName(function),</span>
<span class="fc" id="L75">                    Metric(complexity, allowedComplexity),</span>
<span class="fc" id="L76">                    &quot;The function ${function.nameAsSafeName} appears to be too complex &quot; +</span>
<span class="fc" id="L77">                        &quot;based on Cyclomatic Complexity (complexity: $complexity). &quot; +</span>
<span class="fc" id="L78">                        &quot;The maximum allowed complexity for methods is set to '$allowedComplexity'&quot;</span>
                )
            )
        }
<span class="fc" id="L82">    }</span>

<span class="fc" id="L84">    private fun hasSingleWhenExpression(bodyExpression: KtExpression?): Boolean = when {</span>
<span class="fc bfc" id="L85" title="All 4 branches covered.">        bodyExpression is KtBlockExpression &amp;&amp; bodyExpression.statements.size == 1 -&gt; {</span>
<span class="fc" id="L86">            val statement = bodyExpression.statements.single()</span>
<span class="pc bpc" id="L87" title="1 of 4 branches missed.">            statement is KtWhenExpression || statement.returnsWhenExpression()</span>
        }
        // the case where function-expression syntax is used: `fun test() = when { ... }`
<span class="fc bfc" id="L90" title="All 2 branches covered.">        bodyExpression is KtWhenExpression -&gt; true</span>
<span class="fc" id="L91">        else -&gt; false</span>
<span class="fc" id="L92">    }</span>

    private fun KtExpression.returnsWhenExpression() =
<span class="pc bpc" id="L95" title="2 of 4 branches missed.">        this is KtReturnExpression &amp;&amp; this.returnedExpression is KtWhenExpression</span>

    companion object {
<span class="pc" id="L98">        val DEFAULT_NESTING_FUNCTIONS = listOf(</span>
<span class="fc" id="L99">            &quot;also&quot;,</span>
<span class="fc" id="L100">            &quot;apply&quot;,</span>
<span class="fc" id="L101">            &quot;forEach&quot;,</span>
<span class="fc" id="L102">            &quot;isNotNull&quot;,</span>
<span class="fc" id="L103">            &quot;ifNull&quot;,</span>
<span class="fc" id="L104">            &quot;let&quot;,</span>
<span class="fc" id="L105">            &quot;run&quot;,</span>
<span class="fc" id="L106">            &quot;use&quot;,</span>
<span class="fc" id="L107">            &quot;with&quot;,</span>
        )
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>