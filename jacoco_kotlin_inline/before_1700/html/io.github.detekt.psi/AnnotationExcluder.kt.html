<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationExcluder.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.github.detekt.psi</a> &gt; <span class="el_source">AnnotationExcluder.kt</span></div><h1>AnnotationExcluder.kt</h1><pre class="source lang-java linenums">package io.github.detekt.psi

import io.github.detekt.psi.internal.FullQualifiedNameGuesser
import io.gitlab.arturbosch.detekt.rules.fqNameOrNull
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.psi.KtAnnotationEntry
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtTypeReference
import org.jetbrains.kotlin.resolve.BindingContext

/**
 * Primary use case for an AnnotationExcluder is to decide if a KtElement should be
 * excluded from further analysis. This is done by checking if a special annotation
 * is present over the element.
 */
<span class="fc" id="L16">class AnnotationExcluder(</span>
    root: KtFile,
<span class="fc" id="L18">    private val excludes: List&lt;Regex&gt;,</span>
<span class="fc" id="L19">    private val context: BindingContext,</span>
) {

<span class="fc" id="L22">    private val fullQualifiedNameGuesser = FullQualifiedNameGuesser(root)</span>

    /**
     * Is true if any given annotation name is declared in the SplitPattern
     * which basically describes entries to exclude.
     */
    fun shouldExclude(annotations: List&lt;KtAnnotationEntry&gt;): Boolean =
<span class="pc bpc" id="L29" title="1 of 2 branches missed.">        annotations.any { annotation -&gt; annotation.typeReference?.let { isExcluded(it, context) } ?: false }</span>

    private fun isExcluded(annotation: KtTypeReference, context: BindingContext): Boolean {
<span class="fc bfc" id="L32" title="All 2 branches covered.">        val fqName = if (context == BindingContext.EMPTY) null else annotation.fqNameOrNull(context)</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">        val possibleNames = if (fqName == null) {</span>
<span class="fc" id="L34">            fullQualifiedNameGuesser.getFullQualifiedName(annotation.text.toString())</span>
<span class="fc" id="L35">                .map { it.getPackage() to it }</span>
        } else {
<span class="fc" id="L37">            listOf(fqName.getPackage() to fqName.toString())</span>
        }
<span class="fc" id="L39">            .flatMap { (packaage, fqName) -&gt;</span>
<span class="fc" id="L40">                fqName.substringAfter(&quot;$packaage.&quot;, &quot;&quot;)</span>
<span class="fc" id="L41">                    .split(&quot;.&quot;)</span>
<span class="fc" id="L42">                    .reversed()</span>
<span class="fc bfc" id="L43" title="All 4 branches covered.">                    .scan(&quot;&quot;) { acc, name -&gt; if (acc.isEmpty()) name else &quot;$name.$acc&quot; }</span>
<span class="fc" id="L44">                    .drop(1) + fqName</span>
            }

<span class="fc" id="L47">        return possibleNames.any { name -&gt; name in excludes }</span>
    }
}

private fun FqName.getPackage(): String {
    /* This is a shortcut. Right now we are using the same heuristic that we use when we don't have type solving
     * information. With the type solving information we should know exactly which part is package and which part is
     * class name. But right now I don't know how to extract that information. There is a disabled test that should be
     * enabled once this is solved.
     */
<span class="fc" id="L57">    return this.toString().getPackage()</span>
}

private fun String.getPackage(): String {
    /* We can't know if the annotationText is a full-qualified name or not. We can have these cases:
     * @Component
     * @Component.Factory
     * @dagger.Component.Factory
     * For that reason we use a heuristic here: If the first character is lower case we assume it's a package name
     */
<span class="fc" id="L67">    return this</span>
<span class="fc" id="L68">        .splitToSequence(&quot;.&quot;)</span>
<span class="fc" id="L69">        .takeWhile { it.first().isLowerCase() }</span>
<span class="fc" id="L70">        .joinToString(&quot;.&quot;)</span>
}

private fun KtTypeReference.fqNameOrNull(bindingContext: BindingContext): FqName? =
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">    bindingContext[BindingContext.TYPE, this]?.fqNameOrNull()</span>

private operator fun Iterable&lt;Regex&gt;.contains(a: String?): Boolean {
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">    if (a == null) return false</span>
<span class="fc" id="L78">    return any { it.matches(a) }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>