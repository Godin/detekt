<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ConfigurationCollector.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.generator.collection</a> &gt; <span class="el_source">ConfigurationCollector.kt</span></div><h1>ConfigurationCollector.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.generator.collection

import io.gitlab.arturbosch.detekt.api.ValueWithReason
import io.gitlab.arturbosch.detekt.api.valuesWithReason
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ConfigWithAndroidVariantsSupport.ANDROID_VARIANTS_DELEGATE_NAME
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ConfigWithAndroidVariantsSupport.DEFAULT_ANDROID_VALUE_ARGUMENT_NAME
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ConfigWithAndroidVariantsSupport.isAndroidVariantConfigDelegate
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ConfigWithFallbackSupport.FALLBACK_DELEGATE_NAME
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ConfigWithFallbackSupport.checkUsingInvalidFallbackReference
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ConfigWithFallbackSupport.isFallbackConfigDelegate
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.DefaultValueSupport.getAndroidDefaultValue
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.DefaultValueSupport.getDefaultValue
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.DefaultValueSupport.toDefaultValueIfLiteral
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.StringListSupport.getListDefaultOrNull
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.StringListSupport.hasListDeclaration
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ValuesWithReasonSupport.getValuesWithReasonDefaultOrNull
import io.gitlab.arturbosch.detekt.generator.collection.ConfigurationCollector.ValuesWithReasonSupport.hasValuesWithReasonDeclaration
import io.gitlab.arturbosch.detekt.generator.collection.exception.InvalidDocumentationException
import org.jetbrains.kotlin.psi.KtBinaryExpression
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtCallableReferenceExpression
import org.jetbrains.kotlin.psi.KtConstantExpression
import org.jetbrains.kotlin.psi.KtElement
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtObjectDeclaration
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtStringTemplateExpression
import org.jetbrains.kotlin.psi.KtValueArgument
import org.jetbrains.kotlin.psi.psiUtil.anyDescendantOfType
import org.jetbrains.kotlin.psi.psiUtil.collectDescendantsOfType
import org.jetbrains.kotlin.psi.psiUtil.findDescendantOfType
import org.jetbrains.kotlin.psi.psiUtil.referenceExpression
import io.gitlab.arturbosch.detekt.api.Configuration as ConfigAnnotation

<span class="fc" id="L35">class ConfigurationCollector {</span>

<span class="fc" id="L37">    private val constantsByName = mutableMapOf&lt;String, DefaultValue&gt;()</span>
<span class="fc" id="L38">    private val properties = mutableListOf&lt;KtProperty&gt;()</span>

<span class="fc" id="L40">    fun getConfigurations(): List&lt;Configuration&gt; = properties.mapNotNull { it.parseConfigurationAnnotation() }</span>

    fun addProperty(prop: KtProperty) {
<span class="fc" id="L43">        properties.add(prop)</span>
<span class="fc" id="L44">    }</span>

    fun addCompanion(aRuleCompanion: KtObjectDeclaration) {
<span class="fc" id="L47">        constantsByName.putAll(</span>
<span class="fc" id="L48">            aRuleCompanion</span>
<span class="fc" id="L49">                .collectDescendantsOfType&lt;KtProperty&gt;()</span>
<span class="fc" id="L50">                .mapNotNull(::resolveConstantOrNull)</span>
        )
<span class="fc" id="L52">    }</span>

    private fun resolveConstantOrNull(prop: KtProperty): Pair&lt;String, DefaultValue&gt;? {
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        if (prop.isVar) return null</span>

<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        val propertyName = checkNotNull(prop.name)</span>
<span class="fc" id="L58">        val constantOrNull = prop.getConstantValue()</span>

<span class="pc bpc" id="L60" title="1 of 2 branches missed.">        return constantOrNull?.let { propertyName to it }</span>
    }

    private fun KtProperty.getConstantValue(): DefaultValue? {
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (hasValuesWithReasonDeclaration()) {</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">            return getValuesWithReasonDefaultOrNull()</span>
<span class="nc" id="L66">                ?: invalidDocumentation { &quot;Invalid declaration of values with reasons default for property '$text'&quot; }</span>
        }
<span class="fc bfc" id="L68" title="All 2 branches covered.">        if (hasListDeclaration()) {</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">            return getListDefaultOrNull(emptyMap())</span>
<span class="nc" id="L70">                ?: invalidDocumentation { &quot;Invalid declaration of string list default for property '$text'&quot; }</span>
        }

<span class="pc bpc" id="L73" title="1 of 4 branches missed.">        return findDescendantOfType&lt;KtConstantExpression&gt;()?.toDefaultValueIfLiteral()</span>
<span class="pc bpc" id="L74" title="1 of 2 branches missed.">            ?: findDescendantOfType&lt;KtStringTemplateExpression&gt;()?.toDefaultValueIfLiteral()</span>
    }

<span class="fc" id="L77">    private fun KtProperty.parseConfigurationAnnotation(): Configuration? = when {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">        isAnnotatedWith(ConfigAnnotation::class) -&gt; toConfiguration()</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        isInitializedWithConfigDelegate() -&gt; invalidDocumentation {</span>
<span class="fc" id="L80">            &quot;'$name' is using the config delegate but is not annotated with @Configuration&quot;</span>
        }
<span class="fc" id="L82">        else -&gt; null</span>
<span class="fc" id="L83">    }</span>

    private fun KtProperty.toConfiguration(): Configuration {
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (!isInitializedWithConfigDelegate()) {</span>
<span class="pc" id="L87">            invalidDocumentation { &quot;'$name' is not using one of the config property delegates ($DELEGATE_NAMES)&quot; }</span>
        }

<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (isFallbackConfigDelegate()) {</span>
<span class="fc" id="L91">            checkUsingInvalidFallbackReference(properties)</span>
        }

<span class="pc bpc" id="L94" title="1 of 2 branches missed.">        val propertyName: String = checkNotNull(name)</span>
<span class="fc" id="L95">        val deprecationMessage = firstAnnotationParameterOrNull(Deprecated::class)</span>
<span class="fc" id="L96">        val description: String = firstAnnotationParameter(ConfigAnnotation::class)</span>
<span class="fc" id="L97">        val defaultValue = getDefaultValue(constantsByName)</span>
<span class="fc" id="L98">        val defaultAndroidValue = getAndroidDefaultValue(constantsByName)</span>

<span class="fc" id="L100">        return Configuration(</span>
<span class="fc" id="L101">            name = propertyName,</span>
<span class="fc" id="L102">            description = description,</span>
<span class="fc" id="L103">            defaultValue = defaultValue,</span>
<span class="fc" id="L104">            defaultAndroidValue = defaultAndroidValue,</span>
<span class="fc" id="L105">            deprecated = deprecationMessage,</span>
        )
    }

    private object DefaultValueSupport {
        fun KtProperty.getDefaultValue(constantsByName: Map&lt;String, DefaultValue&gt;): DefaultValue {
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            val defaultValueArgument = getValueArgument(</span>
<span class="fc" id="L112">                name = DEFAULT_VALUE_ARGUMENT_NAME,</span>
                actionForPositionalMatch = { arguments -&gt;
<span class="fc" id="L114">                    when {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                        isFallbackConfigDelegate() -&gt; arguments[1]</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                        isAndroidVariantConfigDelegate() -&gt; arguments[0]</span>
<span class="fc" id="L117">                        else -&gt; arguments[0]</span>
<span class="fc" id="L118">                    }</span>
                }
<span class="nc" id="L120">            ) ?: invalidDocumentation { &quot;'$name' is not a delegated property&quot; }</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">            return checkNotNull(defaultValueArgument.getArgumentExpression()).toDefaultValue(constantsByName)</span>
        }

        fun KtProperty.getAndroidDefaultValue(constantsByName: Map&lt;String, DefaultValue&gt;): DefaultValue? {
<span class="fc" id="L125">            val defaultValueArgument = getValueArgument(</span>
<span class="fc" id="L126">                name = DEFAULT_ANDROID_VALUE_ARGUMENT_NAME,</span>
                actionForPositionalMatch = { arguments -&gt;
<span class="fc" id="L128">                    when {</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">                        isAndroidVariantConfigDelegate() -&gt; arguments[1]</span>
<span class="fc" id="L130">                        else -&gt; null</span>
<span class="fc" id="L131">                    }</span>
                }
            )
<span class="pc bpc" id="L134" title="1 of 4 branches missed.">            return defaultValueArgument?.getArgumentExpression()?.toDefaultValue(constantsByName)</span>
        }

        fun KtExpression.toDefaultValue(constantsByName: Map&lt;String, DefaultValue&gt;): DefaultValue =
<span class="pc bpc" id="L138" title="1 of 8 branches missed.">            getValuesWithReasonDefaultOrNull()</span>
<span class="fc" id="L139">                ?: getListDefaultOrNull(constantsByName)</span>
<span class="fc" id="L140">                ?: toDefaultValueIfLiteral()</span>
<span class="fc" id="L141">                ?: constantsByName[text.withoutQuotes()]</span>
<span class="pc" id="L142">                ?: error(&quot;$text is neither a literal nor a constant&quot;)</span>

<span class="fc" id="L144">        fun KtExpression.toDefaultValueIfLiteral(): DefaultValue? = createDefaultValueIfLiteral(text)</span>
    }

    private object ConfigWithFallbackSupport {
        const val FALLBACK_DELEGATE_NAME = &quot;configWithFallback&quot;
        private const val FALLBACK_ARGUMENT_NAME = &quot;fallbackProperty&quot;

        fun KtProperty.isFallbackConfigDelegate(): Boolean =
<span class="pc bpc" id="L152" title="3 of 6 branches missed.">            delegate?.expression?.referenceExpression()?.text == FALLBACK_DELEGATE_NAME</span>

        fun KtProperty.checkUsingInvalidFallbackReference(properties: List&lt;KtProperty&gt;) {
<span class="fc" id="L155">            val fallbackPropertyReference = getValueArgument(</span>
<span class="fc" id="L156">                name = FALLBACK_ARGUMENT_NAME,</span>
<span class="fc" id="L157">                actionForPositionalMatch = { it.first() }</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">            )?.getReferenceIdentifierOrNull()</span>

<span class="pc bpc" id="L160" title="2 of 4 branches missed.">            val fallbackProperty = properties.find { it.name == fallbackPropertyReference }</span>
<span class="pc bpc" id="L161" title="1 of 4 branches missed.">            if (fallbackProperty == null || !fallbackProperty.isInitializedWithConfigDelegate()) {</span>
<span class="nc" id="L162">                invalidDocumentation {</span>
<span class="fc" id="L163">                    &quot;The fallback property '$fallbackPropertyReference' of property '$name' &quot; +</span>
<span class="fc" id="L164">                        &quot;must also be defined using a config property delegate &quot;</span>
                }
            }
<span class="fc" id="L167">        }</span>

        private fun KtValueArgument.getReferenceIdentifierOrNull(): String? =
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">            (getArgumentExpression() as? KtCallableReferenceExpression)</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">                ?.callableReference</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">                ?.getIdentifier()</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                ?.text</span>
    }

    private object ConfigWithAndroidVariantsSupport {
        const val ANDROID_VARIANTS_DELEGATE_NAME = &quot;configWithAndroidVariants&quot;
        const val DEFAULT_ANDROID_VALUE_ARGUMENT_NAME = &quot;defaultAndroidValue&quot;

        fun KtProperty.isAndroidVariantConfigDelegate(): Boolean =
<span class="pc bpc" id="L181" title="3 of 6 branches missed.">            delegate?.expression?.referenceExpression()?.text == ANDROID_VARIANTS_DELEGATE_NAME</span>
    }

    private object ValuesWithReasonSupport {
        private const val VALUES_WITH_REASON_FACTORY_METHOD = &quot;valuesWithReason&quot;

        fun KtElement.getValuesWithReasonDefaultOrNull(): DefaultValue? =
<span class="fc" id="L188">            getValuesWithReasonDeclarationOrNull()</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                ?.valueArguments</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                ?.map(::toValueWithReason)</span>
<span class="fc" id="L191">                ?.let { DefaultValue.of(valuesWithReason(it)) }</span>

        fun KtElement.getValuesWithReasonDeclarationOrNull(): KtCallExpression? =
<span class="fc" id="L194">            findDescendantOfType { it.isValuesWithReasonDeclaration() }</span>

        fun KtCallExpression.isValuesWithReasonDeclaration(): Boolean =
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            referenceExpression()?.text == VALUES_WITH_REASON_FACTORY_METHOD</span>

        fun KtProperty.hasValuesWithReasonDeclaration(): Boolean =
<span class="fc" id="L200">            anyDescendantOfType&lt;KtCallExpression&gt; { it.isValuesWithReasonDeclaration() }</span>

        private fun toValueWithReason(arg: KtValueArgument): ValueWithReason {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">            val keyToValue = arg.children.first() as? KtBinaryExpression</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            return keyToValue?.let {</span>
<span class="fc" id="L205">                ValueWithReason(</span>
<span class="pc bpc" id="L206" title="3 of 6 branches missed.">                    value = it.left?.text?.withoutQuotes()</span>
<span class="nc" id="L207">                        ?: error(&quot;left side of value with reason argument is null&quot;),</span>
<span class="pc bpc" id="L208" title="3 of 6 branches missed.">                    reason = it.right?.text?.withoutQuotes()</span>
<span class="nc" id="L209">                        ?: error(&quot;right side of value with reason argument is null&quot;)</span>
<span class="fc" id="L210">                )</span>
<span class="nc" id="L211">            } ?: error(&quot;invalid value argument '${arg.text}'&quot;)</span>
        }
    }

    private object StringListSupport {
        private const val LIST_OF = &quot;listOf&quot;
        private const val EMPTY_LIST = &quot;emptyList&quot;
<span class="fc" id="L218">        private val LIST_CREATORS = setOf(LIST_OF, EMPTY_LIST)</span>

        fun KtElement.getListDefaultOrNull(constantsByName: Map&lt;String, DefaultValue&gt;): DefaultValue? =
<span class="pc bpc" id="L221" title="1 of 4 branches missed.">            getListDeclarationOrNull()?.valueArguments?.map {</span>
<span class="pc bpc" id="L222" title="1 of 4 branches missed.">                (constantsByName[it.text]?.getPlainValue() ?: it.text.withoutQuotes())</span>
<span class="fc" id="L223">            }?.let { DefaultValue.of(it) }</span>

        fun KtElement.getListDeclarationOrNull(): KtCallExpression? =
<span class="fc" id="L226">            findDescendantOfType { it.isListDeclaration() }</span>

        fun KtProperty.hasListDeclaration(): Boolean =
<span class="fc" id="L229">            anyDescendantOfType&lt;KtCallExpression&gt; { it.isListDeclaration() }</span>

        fun KtCallExpression.isListDeclaration() =
<span class="pc bpc" id="L232" title="1 of 2 branches missed.">            referenceExpression()?.text in LIST_CREATORS</span>
    }

    companion object {
        private const val SIMPLE_DELEGATE_NAME = &quot;config&quot;
<span class="fc" id="L237">        private val DELEGATE_NAMES = listOf(</span>
<span class="fc" id="L238">            SIMPLE_DELEGATE_NAME,</span>
<span class="fc" id="L239">            FALLBACK_DELEGATE_NAME,</span>
<span class="fc" id="L240">            ANDROID_VARIANTS_DELEGATE_NAME</span>
        )
        private const val DEFAULT_VALUE_ARGUMENT_NAME = &quot;defaultValue&quot;

        private fun KtProperty.isInitializedWithConfigDelegate(): Boolean =
<span class="pc bpc" id="L245" title="2 of 6 branches missed.">            delegate?.expression?.referenceExpression()?.text in DELEGATE_NAMES</span>

        private fun KtElement.invalidDocumentation(message: () -&gt; String): Nothing =
<span class="fc" id="L248">            throw InvalidDocumentationException(&quot;[${containingFile.name}] ${message.invoke()}&quot;)</span>

        private fun KtProperty.getValueArgument(
            name: String,
            actionForPositionalMatch: (List&lt;KtValueArgument&gt;) -&gt; KtValueArgument?
        ): KtValueArgument? {
<span class="pc bpc" id="L254" title="3 of 6 branches missed.">            val callExpression = delegate?.expression as? KtCallExpression ?: return null</span>
<span class="fc" id="L255">            val arguments = callExpression.valueArguments</span>
<span class="fc bfc" id="L256" title="All 8 branches covered.">            return arguments.find { it.getArgumentName()?.text == name } ?: actionForPositionalMatch(arguments)</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>