<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>VarCouldBeVal.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.style</a> &gt; <span class="el_source">VarCouldBeVal.kt</span></div><h1>VarCouldBeVal.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.style

import io.gitlab.arturbosch.detekt.api.ActiveByDefault
import io.gitlab.arturbosch.detekt.api.Alias
import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Configuration
import io.gitlab.arturbosch.detekt.api.DetektVisitor
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.RequiresTypeResolution
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.config
import io.gitlab.arturbosch.detekt.rules.isLateinit
import io.gitlab.arturbosch.detekt.rules.isOverride
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.lexer.KtTokens
import org.jetbrains.kotlin.psi.KtBinaryExpression
import org.jetbrains.kotlin.psi.KtBlockExpression
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtIfExpression
import org.jetbrains.kotlin.psi.KtNameReferenceExpression
import org.jetbrains.kotlin.psi.KtNamedDeclaration
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtObjectDeclaration
import org.jetbrains.kotlin.psi.KtObjectLiteralExpression
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtQualifiedExpression
import org.jetbrains.kotlin.psi.KtReturnExpression
import org.jetbrains.kotlin.psi.KtUnaryExpression
import org.jetbrains.kotlin.psi.psiUtil.collectDescendantsOfType
import org.jetbrains.kotlin.psi.psiUtil.containingClassOrObject
import org.jetbrains.kotlin.psi.psiUtil.isObjectLiteral
import org.jetbrains.kotlin.psi.psiUtil.isPrivate
import org.jetbrains.kotlin.psi.psiUtil.lastBlockStatementOrThis
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.util.getResolvedCall
import org.jetbrains.kotlin.util.containingNonLocalDeclaration

/**
 * Reports var declarations (both local variables and private class properties) that could be val,
 * as they are not re-assigned. Val declarations are assign-once (read-only), which makes understanding
 * the current state easier.
 *
 * &lt;noncompliant&gt;
 * fun example() {
 *     var i = 1 // violation: this variable is never re-assigned
 *     val j = i + 1
 * }
 * &lt;/noncompliant&gt;
 *
 * &lt;compliant&gt;
 * fun example() {
 *     val i = 1
 *     val j = i + 1
 * }
 * &lt;/compliant&gt;
 */
@RequiresTypeResolution
@ActiveByDefault(since = &quot;1.16.0&quot;)
@Alias(&quot;CanBeVal&quot;)
<span class="fc" id="L62">class VarCouldBeVal(config: Config) : Rule(</span>
<span class="fc" id="L63">    config,</span>
<span class="fc" id="L64">    &quot;Var declaration could be val.&quot;</span>
) {

    @Configuration(&quot;Whether to ignore uninitialized lateinit vars&quot;)
<span class="fc" id="L68">    private val ignoreLateinitVar: Boolean by config(defaultValue = false)</span>

    override fun visitKtFile(file: KtFile) {
<span class="fc" id="L71">        super.visitKtFile(file)</span>
<span class="fc" id="L72">        val assignmentVisitor = AssignmentVisitor(bindingContext, ignoreLateinitVar)</span>
<span class="fc" id="L73">        file.accept(assignmentVisitor)</span>

<span class="fc" id="L75">        assignmentVisitor.getNonReAssignedDeclarations().forEach {</span>
<span class="fc" id="L76">            report(</span>
<span class="fc" id="L77">                CodeSmell(</span>
<span class="fc" id="L78">                    Entity.from(it),</span>
<span class="fc" id="L79">                    &quot;Variable '${it.nameAsSafeName.identifier}' could be val.&quot;</span>
                )
            )
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">    }</span>

    @Suppress(&quot;TooManyFunctions&quot;)
<span class="fc" id="L86">    private class AssignmentVisitor(</span>
<span class="fc" id="L87">        private val bindingContext: BindingContext,</span>
<span class="fc" id="L88">        private val ignoreLateinitVar: Boolean</span>
<span class="fc" id="L89">    ) : DetektVisitor() {</span>

<span class="fc" id="L91">        private val declarationCandidates = mutableSetOf&lt;KtNamedDeclaration&gt;()</span>
<span class="fc" id="L92">        private val assignments = mutableMapOf&lt;String, MutableSet&lt;KtExpression&gt;&gt;()</span>
<span class="fc" id="L93">        private val escapeCandidates = mutableMapOf&lt;DeclarationDescriptor, List&lt;KtProperty&gt;&gt;()</span>

        fun getNonReAssignedDeclarations(): List&lt;KtNamedDeclaration&gt; =
<span class="fc" id="L96">            declarationCandidates.filterNot { it.hasAssignments() }</span>

        private fun KtNamedDeclaration.hasAssignments(): Boolean {
<span class="fc" id="L99">            val declarationName = nameAsSafeName.toString()</span>
<span class="fc" id="L100">            val assignments = assignments[declarationName]</span>
<span class="pc bpc" id="L101" title="1 of 6 branches missed.">            if (assignments.isNullOrEmpty()) return false</span>
<span class="fc" id="L102">            val declarationDescriptor =</span>
<span class="fc" id="L103">                bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, this]</span>
<span class="fc" id="L104">            return assignments.any {</span>
<span class="pc bpc" id="L105" title="1 of 6 branches missed.">                it.getResolvedCall(bindingContext)?.resultingDescriptor?.original == declarationDescriptor ||</span>
                    // inside an unknown types context? (example: with-statement with unknown type)
                    // (i.e, it can't be resolved if the assignment is from the context or from an outer variable)
<span class="fc bfc" id="L108" title="All 2 branches covered.">                    it.getResolvedCall(bindingContext) == null</span>
            }
        }

        override fun visitNamedFunction(function: KtNamedFunction) {
            // The super() call should be first in the function so that any properties
            // declared in potential object literals can be evaluated.
<span class="fc" id="L115">            super.visitNamedFunction(function)</span>
<span class="fc" id="L116">            evaluateReturnExpression(function.initializer)</span>
<span class="fc" id="L117">        }</span>

        override fun visitProperty(property: KtProperty) {
<span class="fc" id="L120">            super.visitProperty(property)</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">            if (property.isDeclarationCandidate()) {</span>
<span class="fc" id="L122">                declarationCandidates.add(property)</span>
            }

            // Check for whether the initializer contains an object literal.
<span class="fc" id="L126">            val descriptor = bindingContext[BindingContext.DECLARATION_TO_DESCRIPTOR, property]</span>
<span class="fc" id="L127">            val initializer = property.initializer</span>
<span class="fc bfc" id="L128" title="All 4 branches covered.">            if (descriptor != null &amp;&amp; initializer != null) {</span>
<span class="fc" id="L129">                evaluateAssignmentExpression(descriptor, initializer)</span>
            }
<span class="fc" id="L131">        }</span>

        override fun visitUnaryExpression(expression: KtUnaryExpression) {
<span class="fc" id="L134">            super.visitUnaryExpression(expression)</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">            if (expression.operationToken in unaryAssignmentOperators) {</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">                expression.baseExpression?.let(::visitAssignment)</span>
            }
<span class="fc" id="L138">        }</span>

        override fun visitBinaryExpression(expression: KtBinaryExpression) {
<span class="fc" id="L141">            super.visitBinaryExpression(expression)</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">            if (expression.operationToken in KtTokens.ALL_ASSIGNMENTS) {</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">                expression.left?.let(::visitAssignment)</span>

                // Check for whether the assignment contains an object literal.
<span class="fc bfc" id="L146" title="All 2 branches covered.">                val descriptor = (expression.left as? KtNameReferenceExpression)</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">                    ?.getResolvedCall(bindingContext)</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">                    ?.resultingDescriptor</span>
<span class="fc" id="L149">                val expressionRight = expression.right</span>
<span class="pc bpc" id="L150" title="1 of 4 branches missed.">                if (descriptor != null &amp;&amp; expressionRight != null) {</span>
<span class="fc" id="L151">                    evaluateAssignmentExpression(descriptor, expressionRight)</span>
                }
            }
<span class="fc" id="L154">        }</span>

        override fun visitReturnExpression(expression: KtReturnExpression) {
<span class="fc" id="L157">            super.visitReturnExpression(expression)</span>
<span class="fc" id="L158">            evaluateReturnExpression(expression.returnedExpression)</span>
<span class="fc" id="L159">        }</span>

        private fun evaluateAssignmentExpression(
            descriptor: DeclarationDescriptor,
            rightExpression: KtExpression,
        ) {
<span class="fc" id="L165">            when (rightExpression) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                is KtObjectLiteralExpression -&gt; {</span>
<span class="fc" id="L167">                    escapeCandidates[descriptor] = rightExpression.collectDescendantsOfType {</span>
<span class="fc" id="L168">                        it.isEscapeCandidate()</span>
                    }
                }
<span class="fc bfc" id="L171" title="All 2 branches covered.">                is KtIfExpression -&gt; {</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">                    rightExpression.then?.let { evaluateAssignmentExpression(descriptor, it) }</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                    rightExpression.`else`?.let { evaluateAssignmentExpression(descriptor, it) }</span>
                }
<span class="fc bfc" id="L175" title="All 2 branches covered.">                is KtBlockExpression -&gt; {</span>
<span class="fc" id="L176">                    rightExpression.lastBlockStatementOrThis()</span>
<span class="pc bpc" id="L177" title="2 of 4 branches missed.">                        .takeIf { it != rightExpression }</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                        ?.let { evaluateAssignmentExpression(descriptor, it) }</span>
                }
            }
<span class="fc" id="L181">        }</span>

        private fun evaluateReturnExpression(returnedExpression: KtExpression?) {
<span class="fc" id="L184">            when (returnedExpression) {</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                is KtObjectLiteralExpression -&gt; {</span>
<span class="fc" id="L186">                    returnedExpression.collectDescendantsOfType&lt;KtProperty&gt; {</span>
<span class="fc" id="L187">                        it.isEscapeCandidate()</span>
<span class="fc" id="L188">                    }.forEach(declarationCandidates::remove)</span>
                }
<span class="fc bfc" id="L190" title="All 2 branches covered.">                is KtNameReferenceExpression -&gt; {</span>
<span class="pc bpc" id="L191" title="1 of 4 branches missed.">                    returnedExpression.getResolvedCall(bindingContext)?.resultingDescriptor?.let { descriptor -&gt;</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                        escapeCandidates[descriptor]?.forEach(declarationCandidates::remove)</span>
                    }
                }
<span class="fc bfc" id="L195" title="All 2 branches covered.">                is KtIfExpression -&gt; {</span>
<span class="fc" id="L196">                    evaluateReturnExpression(returnedExpression.then)</span>
<span class="fc" id="L197">                    evaluateReturnExpression(returnedExpression.`else`)</span>
                }
<span class="fc bfc" id="L199" title="All 2 branches covered.">                is KtBlockExpression -&gt; {</span>
<span class="fc" id="L200">                    returnedExpression.lastBlockStatementOrThis()</span>
<span class="pc bpc" id="L201" title="2 of 4 branches missed.">                        .takeIf { it != returnedExpression }</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                        ?.let { evaluateReturnExpression(it) }</span>
                }
            }
<span class="fc" id="L205">        }</span>

        private fun KtProperty.isDeclarationCandidate(): Boolean =
<span class="fc" id="L208">            when {</span>
<span class="pc bpc" id="L209" title="1 of 8 branches missed.">                !isVar || isOverride() || (ignoreLateinitVar &amp;&amp; isLateinit()) -&gt; false</span>
<span class="fc bfc" id="L210" title="All 4 branches covered.">                isLocal || isPrivate() -&gt; true</span>
                else -&gt; {
                    // Check for whether property belongs to an anonymous object
                    // defined in a function.
<span class="fc bfc" id="L214" title="All 2 branches covered.">                    containingClassOrObject</span>
<span class="fc bfc" id="L215" title="All 4 branches covered.">                        ?.takeIf { it.isObjectLiteral() }</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">                        ?.containingNonLocalDeclaration() != null</span>
                }
<span class="fc" id="L218">            }</span>

        private fun KtProperty.isEscapeCandidate(): Boolean =
<span class="pc bpc" id="L221" title="1 of 10 branches missed.">            !isPrivate() &amp;&amp; (containingClassOrObject as? KtObjectDeclaration)?.isObjectLiteral() == true</span>

        private fun visitAssignment(assignedExpression: KtExpression) {
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">            val name = if (assignedExpression is KtQualifiedExpression) {</span>
<span class="fc" id="L225">                assignedExpression.selectorExpression</span>
            } else {
<span class="fc" id="L227">                assignedExpression</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">            }?.text ?: return</span>
<span class="fc" id="L229">            assignments.getOrPut(name) { mutableSetOf() }.add(assignedExpression)</span>
<span class="fc" id="L230">        }</span>
    }

    private companion object {
<span class="fc" id="L234">        private val unaryAssignmentOperators = setOf(KtTokens.MINUSMINUS, KtTokens.PLUSPLUS)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>