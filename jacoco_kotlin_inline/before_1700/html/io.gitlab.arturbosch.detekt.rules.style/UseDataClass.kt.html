<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UseDataClass.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.style</a> &gt; <span class="el_source">UseDataClass.kt</span></div><h1>UseDataClass.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.style

import io.github.detekt.psi.AnnotationExcluder
import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Configuration
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.RequiresTypeResolution
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.config
import io.gitlab.arturbosch.detekt.rules.isOpen
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtParameter
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtSuperTypeListEntry
import org.jetbrains.kotlin.psi.psiUtil.forEachDescendantOfType
import org.jetbrains.kotlin.psi.psiUtil.isAbstract
import org.jetbrains.kotlin.psi.psiUtil.isPrivate
import org.jetbrains.kotlin.psi.psiUtil.isPropertyParameter
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.types.KotlinType

/**
 * Classes that simply hold data should be refactored into a `data class`. Data classes are specialized to hold data
 * and generate `hashCode`, `equals` and `toString` implementations as well.
 *
 * Read more about [data classes](https://kotlinlang.org/docs/data-classes.html)
 *
 * &lt;noncompliant&gt;
 * class DataClassCandidate(val i: Int) {
 *     val i2: Int = 0
 * }
 * &lt;/noncompliant&gt;
 *
 * &lt;compliant&gt;
 * data class DataClass(val i: Int, val i2: Int)
 *
 * // classes with delegating interfaces are compliant
 * interface I
 * class B() : I
 * class A(val b: B) : I by b
 * &lt;/compliant&gt;
 */
@RequiresTypeResolution
<span class="fc" id="L47">class UseDataClass(config: Config) : Rule(</span>
<span class="fc" id="L48">    config,</span>
<span class="fc" id="L49">    &quot;Classes that do nothing but hold data should be replaced with a data class.&quot;</span>
) {

    @Configuration(&quot;allows to provide a list of annotations that disable this check&quot;)
    @Deprecated(&quot;Use `ignoreAnnotated` instead&quot;)
<span class="fc" id="L54">    private val excludeAnnotatedClasses: List&lt;Regex&gt; by config(emptyList&lt;String&gt;()) { list -&gt;</span>
<span class="fc" id="L55">        list.map { it.replace(&quot;.&quot;, &quot;\\.&quot;).replace(&quot;*&quot;, &quot;.*&quot;).toRegex() }</span>
    }

    @Configuration(&quot;allows to relax this rule in order to exclude classes that contains one (or more) vars&quot;)
<span class="fc" id="L59">    private val allowVars: Boolean by config(false)</span>

    override fun visit(root: KtFile) {
<span class="fc" id="L62">        super.visit(root)</span>
<span class="fc" id="L63">        val annotationExcluder = AnnotationExcluder(</span>
<span class="fc" id="L64">            root,</span>
<span class="fc" id="L65">            @Suppress(&quot;DEPRECATION&quot;) excludeAnnotatedClasses,</span>
<span class="fc" id="L66">            bindingContext,</span>
        )
<span class="fc" id="L68">        root.forEachDescendantOfType&lt;KtClass&gt; { visitKlass(it, annotationExcluder) }</span>
<span class="fc" id="L69">    }</span>

    @Suppress(&quot;ComplexMethod&quot;)
    private fun visitKlass(klass: KtClass, annotationExcluder: AnnotationExcluder) {
<span class="fc bfc" id="L73" title="All 4 branches covered.">        if (isIncorrectClassType(klass) || hasOnlyPrivateConstructors(klass)) {</span>
<span class="fc" id="L74">            return</span>
        }
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if (klass.isClosedForExtension() &amp;&amp;</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">            klass.onlyExtendsSimpleInterfaces() &amp;&amp;</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            !annotationExcluder.shouldExclude(klass.annotationEntries)</span>
        ) {
<span class="fc bfc" id="L80" title="All 4 branches covered.">            val declarations = klass.body?.declarations.orEmpty()</span>
<span class="fc" id="L81">            val properties = declarations.filterIsInstance&lt;KtProperty&gt;()</span>
<span class="fc" id="L82">            val functions = declarations.filterIsInstance&lt;KtNamedFunction&gt;()</span>

<span class="fc" id="L84">            val propertyParameters = klass.extractConstructorPropertyParameters()</span>

<span class="fc" id="L86">            val primaryConstructor = bindingContext[BindingContext.CONSTRUCTOR, klass.primaryConstructor]</span>
<span class="pc bpc" id="L87" title="3 of 6 branches missed.">            val primaryConstructorParameterTypes = primaryConstructor?.valueParameters?.map { it.type }.orEmpty()</span>
<span class="pc bpc" id="L88" title="2 of 4 branches missed.">            val classType = primaryConstructor?.containingDeclaration?.defaultType</span>
<span class="fc" id="L89">            val containsFunctions = functions.all { it.isDefaultFunction(classType, primaryConstructorParameterTypes) }</span>
<span class="fc bfc" id="L90" title="All 8 branches covered.">            val containsPropertyOrPropertyParameters = properties.isNotEmpty() || propertyParameters.isNotEmpty()</span>
<span class="fc bfc" id="L91" title="All 4 branches covered.">            val containsVars = properties.any { it.isVar } || propertyParameters.any { it.isMutable }</span>
<span class="fc" id="L92">            val containsDelegatedProperty = properties.any { it.hasDelegate() }</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">            val containsNonPropertyParameter = klass.extractConstructorNonPropertyParameters().isNotEmpty()</span>
<span class="fc bfc" id="L94" title="All 4 branches covered.">            val containsOnlyPropertyParameters = containsPropertyOrPropertyParameters &amp;&amp; !containsNonPropertyParameter</span>

<span class="fc bfc" id="L96" title="All 6 branches covered.">            if (containsFunctions &amp;&amp; !containsDelegatedProperty &amp;&amp; containsOnlyPropertyParameters) {</span>
<span class="pc bpc" id="L97" title="1 of 4 branches missed.">                if (allowVars &amp;&amp; containsVars) {</span>
<span class="fc" id="L98">                    return</span>
                }
<span class="fc" id="L100">                report(</span>
<span class="fc" id="L101">                    CodeSmell(</span>
<span class="fc" id="L102">                        Entity.atName(klass),</span>
<span class="fc" id="L103">                        &quot;The class ${klass.nameAsSafeName} defines no &quot; +</span>
                            &quot;functionality and only holds data. Consider converting it to a data class.&quot;
                    )
                )
            }
        }
<span class="fc" id="L109">    }</span>

<span class="pc bpc" id="L111" title="1 of 4 branches missed.">    private fun KtClass.isClosedForExtension(): Boolean = !isAbstract() &amp;&amp; !isOpen()</span>

    private fun KtClass.onlyExtendsSimpleInterfaces(): Boolean =
<span class="fc bfc" id="L114" title="All 4 branches covered.">        superTypeListEntries.all { it.isInterfaceInSameFile() &amp;&amp; &quot; by &quot; !in it.text }</span>

    private fun KtSuperTypeListEntry.isInterfaceInSameFile(): Boolean {
<span class="fc" id="L117">        val matchingDeclaration = containingKtFile.declarations</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            .firstOrNull { it.name == typeAsUserType?.referencedName }</span>
<span class="pc bpc" id="L119" title="1 of 4 branches missed.">        return matchingDeclaration is KtClass &amp;&amp; matchingDeclaration.isInterface()</span>
    }

    private fun isIncorrectClassType(klass: KtClass) =
<span class="fc bfc" id="L123" title="All 2 branches covered.">        klass.isData() ||</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">            klass.isEnum() ||</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            klass.isAnnotation() ||</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">            klass.isSealed() ||</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            klass.isInline() ||</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            klass.isValue() ||</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            klass.isInner()</span>

    private fun hasOnlyPrivateConstructors(klass: KtClass): Boolean {
<span class="fc" id="L132">        val primaryConstructor = klass.primaryConstructor</span>
<span class="fc bfc" id="L133" title="All 4 branches covered.">        return (primaryConstructor == null || primaryConstructor.isPrivate()) &amp;&amp;</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">            klass.secondaryConstructors.all { it.isPrivate() }</span>
    }

    private fun KtClass.extractConstructorPropertyParameters(): List&lt;KtParameter&gt; =
<span class="fc" id="L138">        getPrimaryConstructorParameterList()</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">            ?.parameters</span>
<span class="pc bpc" id="L140" title="1 of 2 branches missed.">            ?.filter { it.isPropertyParameter() }</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">            .orEmpty()</span>

    private fun KtClass.extractConstructorNonPropertyParameters(): List&lt;KtParameter&gt; =
<span class="fc" id="L144">        getPrimaryConstructorParameterList()</span>
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            ?.parameters</span>
<span class="pc bpc" id="L146" title="1 of 4 branches missed.">            ?.filter { !it.isPropertyParameter() }</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            .orEmpty()</span>

    private fun KtNamedFunction.isDefaultFunction(
        classType: KotlinType?,
        primaryConstructorParameterTypes: List&lt;KotlinType&gt;
    ): Boolean =
<span class="fc" id="L153">        when (name) {</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            !in DEFAULT_FUNCTION_NAMES -&gt; false</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            &quot;copy&quot; -&gt; {</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">                if (classType != null) {</span>
<span class="fc" id="L157">                    val descriptor = bindingContext[BindingContext.FUNCTION, this]</span>
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">                    val returnType = descriptor?.returnType</span>
<span class="pc bpc" id="L159" title="3 of 6 branches missed.">                    val parameterTypes = descriptor?.valueParameters?.map { it.type }.orEmpty()</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">                    returnType == classType &amp;&amp;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                        parameterTypes.size == primaryConstructorParameterTypes.size &amp;&amp;</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">                        parameterTypes.zip(primaryConstructorParameterTypes).all { it.first == it.second }</span>
                } else {
<span class="nc" id="L164">                    true</span>
                }
            }
<span class="fc" id="L167">            else -&gt; true</span>
<span class="fc" id="L168">        }</span>

    companion object {
<span class="fc" id="L171">        private val DEFAULT_FUNCTION_NAMES = hashSetOf(&quot;hashCode&quot;, &quot;equals&quot;, &quot;toString&quot;, &quot;copy&quot;)</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>