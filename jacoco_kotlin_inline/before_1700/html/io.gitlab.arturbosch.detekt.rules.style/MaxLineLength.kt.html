<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MaxLineLength.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.style</a> &gt; <span class="el_source">MaxLineLength.kt</span></div><h1>MaxLineLength.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.style

import io.github.detekt.psi.absolutePath
import io.gitlab.arturbosch.detekt.api.ActiveByDefault
import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Configuration
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Location
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.SourceLocation
import io.gitlab.arturbosch.detekt.api.TextLocation
import io.gitlab.arturbosch.detekt.api.config
import io.gitlab.arturbosch.detekt.rules.lastArgumentMatchesKotlinReferenceUrlSyntax
import io.gitlab.arturbosch.detekt.rules.lastArgumentMatchesMarkdownUrlSyntax
import io.gitlab.arturbosch.detekt.rules.lastArgumentMatchesUrl
import org.jetbrains.kotlin.KtPsiSourceFileLinesMapping
import org.jetbrains.kotlin.com.intellij.openapi.util.TextRange
import org.jetbrains.kotlin.com.intellij.psi.PsiElement
import org.jetbrains.kotlin.diagnostics.DiagnosticUtils.getLineAndColumnRangeInPsiFile
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtStringTemplateExpression
import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType

/**
 * This rule reports lines of code which exceed a defined maximum line length.
 *
 * Long lines might be hard to read on smaller screens or printouts. Additionally, having a maximum line length
 * in the codebase will help make the code more uniform.
 */
@ActiveByDefault(since = &quot;1.0.0&quot;)
<span class="fc" id="L32">class MaxLineLength(config: Config) : Rule(</span>
<span class="fc" id="L33">    config,</span>
<span class="fc" id="L34">    &quot;Line detected, which is longer than the defined maximum line length in the code style.&quot;</span>
) {

    @Suppress(&quot;MemberNameEqualsClassName&quot;)
    @Configuration(&quot;maximum line length&quot;)
<span class="fc" id="L39">    private val maxLineLength: Int by config(DEFAULT_IDEA_LINE_LENGTH)</span>

    @Configuration(&quot;if package statements should be ignored&quot;)
<span class="fc" id="L42">    private val excludePackageStatements: Boolean by config(true)</span>

    @Configuration(&quot;if import statements should be ignored&quot;)
<span class="fc" id="L45">    private val excludeImportStatements: Boolean by config(true)</span>

    @Configuration(&quot;if comment statements should be ignored&quot;)
<span class="fc" id="L48">    private val excludeCommentStatements: Boolean by config(false)</span>

    @Configuration(&quot;if raw strings should be ignored&quot;)
<span class="fc" id="L51">    private val excludeRawStrings: Boolean by config(true)</span>

    override fun visitKtFile(file: KtFile) {
<span class="fc" id="L54">        super.visitKtFile(file)</span>

<span class="fc" id="L56">        val sourceFileLinesMapping = KtPsiSourceFileLinesMapping(file)</span>

<span class="fc" id="L58">        file.text.lines().withIndex()</span>
<span class="fc" id="L59">            .filterNot { (index, line) -&gt; isValidLine(file, sourceFileLinesMapping.getLineStartOffset(index), line) }</span>
<span class="fc" id="L60">            .forEach { (index, line) -&gt;</span>
<span class="fc" id="L61">                val offset = sourceFileLinesMapping.getLineStartOffset(index)</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">                val ktElement = findFirstMeaningfulKtElementInParents(file, offset, line) ?: file</span>
<span class="fc" id="L63">                val textRange = TextRange(offset, offset + line.length)</span>
<span class="fc" id="L64">                val lineAndColumnRange = getLineAndColumnRangeInPsiFile(file, textRange)</span>
<span class="fc" id="L65">                val location =</span>
<span class="fc" id="L66">                    Location(</span>
<span class="fc" id="L67">                        source = SourceLocation(lineAndColumnRange.start.line, lineAndColumnRange.start.column),</span>
<span class="fc" id="L68">                        endSource = SourceLocation(lineAndColumnRange.end.line, lineAndColumnRange.end.column),</span>
<span class="fc" id="L69">                        text = TextLocation(offset, offset + line.length),</span>
<span class="fc" id="L70">                        path = file.absolutePath(),</span>
                    )
<span class="fc" id="L72">                report(CodeSmell(Entity.from(ktElement, location), description))</span>
<span class="fc" id="L73">            }</span>
<span class="fc" id="L74">    }</span>

    private fun isValidLine(file: KtFile, offset: Int, line: String): Boolean {
<span class="fc" id="L77">        val isUrl = line.lastArgumentMatchesUrl()</span>
<span class="fc" id="L78">        val isMarkdownOrRefUrl =</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">            line.lastArgumentMatchesMarkdownUrlSyntax() ||</span>
<span class="fc bfc" id="L80" title="All 2 branches covered.">                line.lastArgumentMatchesKotlinReferenceUrlSyntax()</span>
<span class="fc bfc" id="L81" title="All 8 branches covered.">        return line.length &lt;= maxLineLength || isIgnoredStatement(file, offset, line) || isUrl || isMarkdownOrRefUrl</span>
    }

    private fun isIgnoredStatement(file: KtFile, offset: Int, line: String): Boolean =
<span class="fc bfc" id="L85" title="All 2 branches covered.">        containsIgnoredPackageStatement(line) ||</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">            containsIgnoredImportStatement(line) ||</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">            containsIgnoredCommentStatement(line) ||</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">            containsIgnoredRawString(file, offset, line)</span>

    private fun containsIgnoredRawString(file: KtFile, offset: Int, line: String): Boolean {
<span class="fc bfc" id="L91" title="All 2 branches covered.">        if (!excludeRawStrings) return false</span>

<span class="pc bpc" id="L93" title="1 of 4 branches missed.">        return findKtElementInParents(file, offset, line).lastOrNull()?.isInsideRawString() == true</span>
    }

    private fun containsIgnoredPackageStatement(line: String): Boolean {
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (!excludePackageStatements) return false</span>

<span class="fc" id="L99">        return line.trimStart().startsWith(&quot;package &quot;)</span>
    }

    private fun containsIgnoredImportStatement(line: String): Boolean {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (!excludeImportStatements) return false</span>

<span class="fc" id="L105">        return line.trimStart().startsWith(&quot;import &quot;)</span>
    }

    private fun containsIgnoredCommentStatement(line: String): Boolean {
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (!excludeCommentStatements) return false</span>

<span class="fc bfc" id="L111" title="All 2 branches covered.">        return line.trimStart().startsWith(&quot;//&quot;) ||</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            line.trimStart().startsWith(&quot;/*&quot;) ||</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">            line.trimStart().startsWith(&quot;*&quot;)</span>
    }

    companion object {
        private const val DEFAULT_IDEA_LINE_LENGTH = 120
<span class="fc" id="L118">        private val BLANK_OR_QUOTES = &quot;&quot;&quot;[\s&quot;]*&quot;&quot;&quot;.toRegex()</span>

        private fun findFirstMeaningfulKtElementInParents(file: KtFile, offset: Int, line: String): PsiElement? =
<span class="fc bfc" id="L121" title="All 2 branches covered.">            findKtElementInParents(file, offset, line).firstOrNull { !BLANK_OR_QUOTES.matches(it.text) }</span>
    }
}

private fun PsiElement.isInsideRawString(): Boolean =
<span class="pc bpc" id="L126" title="1 of 4 branches missed.">    this is KtStringTemplateExpression || getNonStrictParentOfType&lt;KtStringTemplateExpression&gt;() != null</span>
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202409090933</span></div></body></html>