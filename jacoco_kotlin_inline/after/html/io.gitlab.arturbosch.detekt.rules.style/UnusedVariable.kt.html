<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnusedVariable.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.style</a> &gt; <span class="el_source">UnusedVariable.kt</span></div><h1>UnusedVariable.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.style

import io.gitlab.arturbosch.detekt.api.ActiveByDefault
import io.gitlab.arturbosch.detekt.api.Alias
import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Configuration
import io.gitlab.arturbosch.detekt.api.DetektVisitor
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.RequiresTypeResolution
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.api.config
import org.jetbrains.kotlin.com.intellij.psi.PsiElement
import org.jetbrains.kotlin.descriptors.DeclarationDescriptor
import org.jetbrains.kotlin.descriptors.impl.LocalVariableDescriptor
import org.jetbrains.kotlin.load.kotlin.toSourceElement
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtDeclaration
import org.jetbrains.kotlin.psi.KtFile
import org.jetbrains.kotlin.psi.KtNameReferenceExpression
import org.jetbrains.kotlin.psi.KtNamedDeclaration
import org.jetbrains.kotlin.psi.KtParameter
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtReferenceExpression
import org.jetbrains.kotlin.psi.KtValueArgumentList
import org.jetbrains.kotlin.psi.KtVariableDeclaration
import org.jetbrains.kotlin.psi.psiUtil.getChildrenOfType
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.bindingContextUtil.getReferenceTargets
import org.jetbrains.kotlin.resolve.source.getPsi
import org.jetbrains.kotlin.resolve.source.toSourceElement

/**
 * An unused variable can be removed to simplify the source file.
 *
 * &lt;noncompliant&gt;
 * fun foo() {
 *     val unused = &quot;unused&quot;
 * }
 * &lt;/noncompliant&gt;
 *
 * &lt;compliant&gt;
 * fun foo() {
 *     val used = &quot;used&quot;
 *     println(used)
 * }
 * &lt;/compliant&gt;
 */
@RequiresTypeResolution
@ActiveByDefault(since = &quot;2.0.0&quot;)
@Alias(&quot;UNUSED_VARIABLE&quot;, &quot;unused&quot;)
<span class="fc" id="L52">class UnusedVariable(config: Config) : Rule(</span>
<span class="fc" id="L53">    config,</span>
<span class="fc" id="L54">    &quot;Variable is unused and should be removed.&quot;</span>
) {
    @Configuration(&quot;unused variables names matching this regex are ignored&quot;)
<span class="fc" id="L57">    private val allowedNames: Regex by config(</span>
<span class="fc" id="L58">        &quot;ignored|_&quot;,</span>
<span class="fc" id="L59">        String::toRegex</span>
    )

    override fun visit(root: KtFile) {
<span class="fc" id="L63">        super.visit(root)</span>
<span class="fc" id="L64">        val visitor = UnusedVariableVisitor(allowedNames, bindingContext)</span>
<span class="fc" id="L65">        root.accept(visitor)</span>
<span class="fc" id="L66">        visitor.getUnusedReports().forEach { report(it) }</span>
<span class="fc" id="L67">    }</span>
}

@Suppress(&quot;unused&quot;)
<span class="fc" id="L71">private class UnusedVariableVisitor(</span>
<span class="fc" id="L72">    private val allowedNames: Regex,</span>
<span class="fc" id="L73">    private val bindingContext: BindingContext,</span>
<span class="fc" id="L74">) : DetektVisitor() {</span>

<span class="fc" id="L76">    private val variables = mutableMapOf&lt;PsiElement, KtNamedDeclaration&gt;()</span>
<span class="fc" id="L77">    private val usedVariables = mutableSetOf&lt;PsiElement&gt;()</span>

    fun getUnusedReports(): List&lt;CodeSmell&gt; {
<span class="fc" id="L80">        val unusedVariableNames = variables</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">            .filterKeys { it !in usedVariables }</span>

<span class="fc" id="L83">        return unusedVariableNames</span>
<span class="fc" id="L84">            .values</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">            .filter { !allowedNames.matches(it.nameAsSafeName.identifier) }</span>
<span class="fc" id="L86">            .map {</span>
<span class="fc" id="L87">                CodeSmell(</span>
<span class="fc" id="L88">                    entity = Entity.atName(it),</span>
<span class="fc" id="L89">                    message = &quot;Variable `${it.nameAsSafeName.identifier}` is unused.&quot;</span>
<span class="fc" id="L90">                )</span>
            }
    }

    override fun visitDeclaration(dcl: KtDeclaration) {
<span class="fc" id="L95">        super.visitDeclaration(dcl)</span>

<span class="fc" id="L97">        when (dcl) {</span>
<span class="fc bfc" id="L98" title="All 4 branches covered.">            is KtProperty -&gt; if (dcl.isLocal) {</span>
<span class="fc" id="L99">                registerNewDeclaration(dcl)</span>
            }

<span class="fc bfc" id="L102" title="All 2 branches covered.">            is KtParameter -&gt; when {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">                dcl.destructuringDeclaration != null -&gt;</span>
<span class="fc" id="L104">                    dcl.destructuringDeclaration</span>
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">                        ?.entries</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">                        ?.forEach(::registerNewDeclaration)</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                dcl.isLoopParameter -&gt; registerNewDeclaration(dcl)</span>
            }

<span class="fc bfc" id="L110" title="All 2 branches covered.">            is KtVariableDeclaration -&gt; registerNewDeclaration(dcl)</span>
        }
<span class="fc" id="L112">    }</span>

    override fun visitReferenceExpression(expression: KtReferenceExpression) {
<span class="fc" id="L115">        super.visitReferenceExpression(expression)</span>

<span class="fc" id="L117">        val references = when (expression) {</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">            is KtNameReferenceExpression -&gt; expression.getReferenceTargets(bindingContext)</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">            is KtCallExpression -&gt; {</span>
<span class="fc" id="L120">                expression.getChildrenOfType&lt;KtValueArgumentList&gt;()</span>
<span class="fc" id="L121">                    .flatMap { it.arguments }</span>
<span class="fc" id="L122">                    .flatMap {</span>
<span class="pc bpc" id="L123" title="2 of 4 branches missed.">                        it.getArgumentExpression()?.getReferenceTargets(bindingContext).orEmpty()</span>
                    }
            }

<span class="fc" id="L127">            else -&gt; return</span>
        }

<span class="fc" id="L130">        references</span>
<span class="fc" id="L131">            .filterIsInstance&lt;LocalVariableDescriptor&gt;()</span>
<span class="fc" id="L132">            .forEach(::registerVariableUse)</span>
<span class="fc" id="L133">    }</span>

    private fun registerVariableUse(descriptor: DeclarationDescriptor) {
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">        descriptor.toSourceElement.getPsi()?.also {</span>
<span class="fc" id="L137">            usedVariables.add(it)</span>
<span class="fc" id="L138">        }</span>
<span class="fc" id="L139">    }</span>

    private fun registerNewDeclaration(declaration: KtNamedDeclaration) {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        declaration.toSourceElement().getPsi()?.also {</span>
<span class="fc" id="L143">            variables[it] = declaration</span>
<span class="fc" id="L144">        }</span>
<span class="fc" id="L145">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202408290909</span></div></body></html>