<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnnecessaryInnerClass.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.style</a> &gt; <span class="el_source">UnnecessaryInnerClass.kt</span></div><h1>UnnecessaryInnerClass.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.style

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.RequiresTypeResolution
import io.gitlab.arturbosch.detekt.api.Rule
import org.jetbrains.kotlin.descriptors.ClassifierDescriptor
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtReferenceExpression
import org.jetbrains.kotlin.psi.KtThisExpression
import org.jetbrains.kotlin.psi.psiUtil.containingClass
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.util.getResolvedCall
import org.jetbrains.kotlin.resolve.descriptorUtil.classId

/**
 * This rule reports unnecessary inner classes. Nested classes that do not access members from the outer class do
 * not require the `inner` qualifier.
 *
 * &lt;noncompliant&gt;
 * class A {
 *     val foo = &quot;BAR&quot;
 *
 *     inner class B {
 *         val fizz = &quot;BUZZ&quot;
 *
 *         fun printFizz() {
 *             println(fizz)
 *         }
 *     }
 * }
 * &lt;/noncompliant&gt;
 */
@Suppress(&quot;TooManyFunctions&quot;)
@RequiresTypeResolution
<span class="fc" id="L38">class UnnecessaryInnerClass(config: Config) : Rule(</span>
<span class="fc" id="L39">    config,</span>
<span class="fc" id="L40">    &quot;The 'inner' qualifier is unnecessary.&quot;</span>
) {

<span class="fc" id="L43">    private val candidateClassToParentClasses = mutableMapOf&lt;KtClass, List&lt;KtClass&gt;&gt;()</span>
<span class="fc" id="L44">    private val classChain = ArrayDeque&lt;KtClass&gt;()</span>

    override fun visitClass(klass: KtClass) {
<span class="fc" id="L47">        classChain.add(klass)</span>
<span class="fc bfc" id="L48" title="All 2 branches covered.">        if (klass.isInner()) {</span>
<span class="fc" id="L49">            candidateClassToParentClasses[klass] = findParentClasses(klass)</span>
        }

        // Visit the class to determine whether it contains any references
        // to outer class members.
<span class="fc" id="L54">        super.visitClass(klass)</span>

<span class="fc bfc" id="L56" title="All 4 branches covered.">        if (klass.isInner() &amp;&amp; candidateClassToParentClasses.contains(klass)) {</span>
<span class="fc" id="L57">            report(</span>
<span class="fc" id="L58">                CodeSmell(</span>
<span class="fc" id="L59">                    Entity.Companion.from(klass),</span>
<span class="fc" id="L60">                    &quot;Class '${klass.name}' does not require `inner` keyword.&quot;</span>
                )
            )
<span class="fc" id="L63">            candidateClassToParentClasses.remove(klass)</span>
        }
<span class="fc" id="L65">        classChain.removeLast()</span>
<span class="fc" id="L66">    }</span>

    override fun visitReferenceExpression(expression: KtReferenceExpression) {
<span class="fc" id="L69">        super.visitReferenceExpression(expression)</span>
<span class="fc" id="L70">        checkForOuterUsage { findResolvedContainingClassId(expression) }</span>
<span class="fc" id="L71">    }</span>

    override fun visitThisExpression(expression: KtThisExpression) {
<span class="fc" id="L74">        checkForOuterUsage { expression.referenceClassId() }</span>
<span class="fc" id="L75">    }</span>

    // Replace this &quot;constructor().apply{}&quot; pattern with buildList() when the Kotlin
    // API version is upgraded to 1.6
<span class="fc" id="L79">    private fun findParentClasses(ktClass: KtClass): List&lt;KtClass&gt; = ArrayList&lt;KtClass&gt;().apply {</span>
<span class="fc" id="L80">        var containingClass = ktClass.containingClass()</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        while (containingClass != null) {</span>
<span class="fc" id="L82">            add(containingClass)</span>
<span class="fc" id="L83">            containingClass = containingClass.containingClass()</span>
        }
<span class="fc" id="L85">    }</span>

    private fun checkForOuterUsage(getTargetClassId: () -&gt; ClassId?) {
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">        val currentClass = classChain.lastOrNull() ?: return</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">        val parentClasses = candidateClassToParentClasses[currentClass] ?: return</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">        val targetClassId = getTargetClassId() ?: return</span>
        /*
         * If class A -&gt; inner class B -&gt; inner class C, and class C has outer usage of A,
         * then both B and C should stay as inner classes.
         */
<span class="fc" id="L96">        val index = parentClasses.indexOfFirst { it.getClassId() == targetClassId }</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (index &gt;= 0) {</span>
<span class="fc" id="L98">            candidateClassToParentClasses.remove(currentClass)</span>
<span class="fc" id="L99">            parentClasses.subList(0, index).forEach { candidateClassToParentClasses.remove(it) }</span>
        }
<span class="fc" id="L101">    }</span>

    private fun findResolvedContainingClassId(expression: KtReferenceExpression): ClassId? =
<span class="fc bfc" id="L104" title="All 4 branches covered.">        (bindingContext[BindingContext.REFERENCE_TARGET, expression]?.containingDeclaration as? ClassifierDescriptor)</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">            ?.classId</span>

    private fun KtThisExpression.referenceClassId(): ClassId? =
<span class="fc" id="L108">        getResolvedCall(bindingContext)</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">            ?.resultingDescriptor</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            ?.returnType</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">            ?.constructor</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">            ?.declarationDescriptor</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            ?.classId</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202408290909</span></div></body></html>