<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UselessPostfixExpression.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.bugs</a> &gt; <span class="el_source">UselessPostfixExpression.kt</span></div><h1>UselessPostfixExpression.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.bugs

import io.gitlab.arturbosch.detekt.api.ActiveByDefault
import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.Rule
import org.jetbrains.kotlin.lexer.KtTokens.MINUSMINUS
import org.jetbrains.kotlin.lexer.KtTokens.PLUSPLUS
import org.jetbrains.kotlin.psi.KtBinaryExpression
import org.jetbrains.kotlin.psi.KtClass
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtPostfixExpression
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtReturnExpression
import org.jetbrains.kotlin.psi.psiUtil.anyDescendantOfType
import org.jetbrains.kotlin.psi.psiUtil.getChildrenOfType
import org.jetbrains.kotlin.psi.psiUtil.getNonStrictParentOfType
import org.jetbrains.kotlin.psi.psiUtil.isPropertyParameter

/**
 * Reports postfix expressions (++, --) which are unused and thus unnecessary.
 * This leads to confusion as a reader of the code might think the value will be incremented/decremented.
 * However, the value is replaced with the original value which might lead to bugs.
 *
 * &lt;noncompliant&gt;
 * var i = 0
 * i = i--
 * i = 1 + i++
 * i = i++ + 1
 *
 * fun foo(): Int {
 *     var i = 0
 *     // ...
 *     return i++
 * }
 * &lt;/noncompliant&gt;
 *
 * &lt;compliant&gt;
 * var i = 0
 * i--
 * i = i + 2
 * i = i + 2
 *
 * fun foo(): Int {
 *     var i = 0
 *     // ...
 *     i++
 *     return i
 * }
 * &lt;/compliant&gt;
 */
@ActiveByDefault(since = &quot;1.21.0&quot;)
<span class="fc" id="L55">class UselessPostfixExpression(config: Config) : Rule(</span>
<span class="fc" id="L56">    config,</span>
<span class="fc" id="L57">    &quot;The incremented or decremented value is unused. This value is replaced with the original value.&quot;</span>
) {

<span class="pc" id="L60">    var properties = emptySet&lt;String?&gt;()</span>

    override fun visitClass(klass: KtClass) {
<span class="fc" id="L63">        properties = klass.getProperties()</span>
<span class="fc" id="L64">            .map { it.name }</span>
<span class="fc" id="L65">            .union(klass.primaryConstructorParameters.filter { it.isPropertyParameter() }.map { it.name })</span>
<span class="fc" id="L66">        super.visitClass(klass)</span>
<span class="fc" id="L67">    }</span>

    override fun visitReturnExpression(expression: KtReturnExpression) {
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        val postfixExpression = expression.returnedExpression?.asPostFixExpression()</span>

<span class="fc bfc" id="L72" title="All 4 branches covered.">        if (postfixExpression != null &amp;&amp; postfixExpression.shouldBeReported()) {</span>
<span class="fc" id="L73">            report(postfixExpression)</span>
        }

<span class="fc" id="L76">        expression.returnedExpression</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">            ?.let(this::getPostfixExpressionChildren)</span>
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">            ?.filter { it.shouldBeReported() }</span>
<span class="fc" id="L79">            ?.forEach(this::report)</span>
<span class="fc" id="L80">    }</span>

    override fun visitBinaryExpression(expression: KtBinaryExpression) {
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">        val postfixExpression = expression.right?.asPostFixExpression()</span>
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">        val leftIdentifierText = expression.left?.text</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">        postfixExpression?.let { checkPostfixExpression(it, leftIdentifierText) }</span>
<span class="fc" id="L86">        expression.right</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">            ?.let(this::getPostfixExpressionChildren)</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            ?.forEach { checkPostfixExpression(it, leftIdentifierText) }</span>
<span class="fc" id="L89">    }</span>

<span class="fc bfc" id="L91" title="All 2 branches covered.">    private fun KtExpression.asPostFixExpression() = if (this is KtPostfixExpression &amp;&amp;</span>
<span class="fc bfc" id="L92" title="All 4 branches covered.">        (operationToken === PLUSPLUS || operationToken === MINUSMINUS)</span>
    ) {
<span class="fc" id="L94">        this</span>
    } else {
<span class="fc" id="L96">        null</span>
<span class="fc" id="L97">    }</span>

    private fun checkPostfixExpression(postfixExpression: KtPostfixExpression, leftIdentifierText: String?) {
<span class="pc bpc" id="L100" title="1 of 4 branches missed.">        if (leftIdentifierText == postfixExpression.firstChild?.text) {</span>
<span class="fc" id="L101">            report(postfixExpression)</span>
        }
<span class="fc" id="L103">    }</span>

    private fun KtPostfixExpression.shouldBeReported(): Boolean {
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        val postfixReceiverName = this.baseExpression?.text</span>
<span class="fc" id="L107">        return getNonStrictParentOfType&lt;KtNamedFunction&gt;()</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">            ?.anyDescendantOfType&lt;KtProperty&gt; { it.name == postfixReceiverName }</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">            ?: !properties.contains(postfixReceiverName)</span>
    }

    private fun report(postfixExpression: KtPostfixExpression) {
<span class="fc" id="L113">        report(</span>
<span class="fc" id="L114">            CodeSmell(</span>
<span class="fc" id="L115">                Entity.from(postfixExpression),</span>
<span class="fc" id="L116">                &quot;The result of the postfix expression: &quot; +</span>
<span class="fc" id="L117">                    &quot;${postfixExpression.text} will not be used and is therefore useless.&quot;</span>
            )
        )
<span class="fc" id="L120">    }</span>

    private fun getPostfixExpressionChildren(expression: KtExpression) =
<span class="fc" id="L123">        expression.getChildrenOfType&lt;KtPostfixExpression&gt;()</span>
<span class="pc bpc" id="L124" title="1 of 4 branches missed.">            .filter { it.operationToken === PLUSPLUS || it.operationToken === MINUSMINUS }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202408290909</span></div></body></html>