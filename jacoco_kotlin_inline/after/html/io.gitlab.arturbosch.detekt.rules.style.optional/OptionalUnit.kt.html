<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OptionalUnit.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.style.optional</a> &gt; <span class="el_source">OptionalUnit.kt</span></div><h1>OptionalUnit.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.style.optional

import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.RequiresTypeResolution
import io.gitlab.arturbosch.detekt.api.Rule
import io.gitlab.arturbosch.detekt.rules.isOverride
import org.jetbrains.kotlin.cfg.WhenChecker
import org.jetbrains.kotlin.config.AnalysisFlags
import org.jetbrains.kotlin.config.ExplicitApiMode
import org.jetbrains.kotlin.psi.KtBlockExpression
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtIfExpression
import org.jetbrains.kotlin.psi.KtNameReferenceExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtTypeReference
import org.jetbrains.kotlin.psi.KtWhenExpression
import org.jetbrains.kotlin.psi.psiUtil.isPublic
import org.jetbrains.kotlin.psi.psiUtil.siblings
import org.jetbrains.kotlin.resolve.bindingContextUtil.isUsedAsExpression
import org.jetbrains.kotlin.resolve.calls.util.getResolvedCall
import org.jetbrains.kotlin.resolve.calls.util.getType
import org.jetbrains.kotlin.types.typeUtil.isNothing
import org.jetbrains.kotlin.types.typeUtil.isTypeParameter
import org.jetbrains.kotlin.types.typeUtil.isUnit
import org.jetbrains.kotlin.utils.addToStdlib.firstIsInstanceOrNull

/**
 * It is not necessary to define a return type of `Unit` on functions or to specify a lone Unit statement.
 * This rule detects and reports instances where the `Unit` return type is specified on functions and the occurrences
 * of a lone Unit statement.
 *
 * &lt;noncompliant&gt;
 * fun foo(): Unit {
 *     return Unit
 * }
 * fun foo() = Unit
 *
 * fun doesNothing() {
 *     Unit
 * }
 * &lt;/noncompliant&gt;
 *
 * &lt;compliant&gt;
 * fun foo() { }
 *
 * // overridden no-op functions are allowed
 * override fun foo() = Unit
 * &lt;/compliant&gt;
 */
@RequiresTypeResolution
<span class="fc" id="L53">class OptionalUnit(config: Config) : Rule(</span>
<span class="fc" id="L54">    config,</span>
<span class="fc" id="L55">    &quot;Return type of `Unit` is unnecessary and can be safely removed.&quot;</span>
) {

    override fun visitNamedFunction(function: KtNamedFunction) {
<span class="fc" id="L59">        val typeReference = function.typeReference</span>
<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (typeReference != null) {</span>
<span class="fc" id="L61">            checkFunctionWithExplicitReturnType(function, typeReference)</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">        } else if (!function.isOverride()) {</span>
<span class="fc" id="L63">            checkFunctionWithInferredReturnType(function)</span>
        }
<span class="fc" id="L65">        super.visitNamedFunction(function)</span>
<span class="fc" id="L66">    }</span>

    override fun visitBlockExpression(expression: KtBlockExpression) {
<span class="fc" id="L69">        val statements = expression.statements</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">        val lastStatement = statements.lastOrNull() ?: return</span>
<span class="fc" id="L71">        statements</span>
<span class="fc" id="L72">            .filter {</span>
<span class="fc" id="L73">                when {</span>
<span class="fc bfc" id="L74" title="All 4 branches covered.">                    it !is KtNameReferenceExpression || it.text != UNIT -&gt; false</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">                    it != lastStatement -&gt; true</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">                    !it.isUsedAsExpression(bindingContext) -&gt; true</span>
                    else -&gt; {
<span class="fc" id="L78">                        val prev =</span>
<span class="fc" id="L79">                            it.siblings(forward = false, withItself = false).firstIsInstanceOrNull&lt;KtExpression&gt;()</span>
<span class="pc bpc" id="L80" title="2 of 10 branches missed.">                        prev?.getType(bindingContext)?.isUnit() == true &amp;&amp; prev.canBeUsedAsValue()</span>
                    }
<span class="fc" id="L82">                }</span>
            }
<span class="fc" id="L84">            .onEach {</span>
<span class="fc" id="L85">                report(</span>
<span class="fc" id="L86">                    CodeSmell(</span>
<span class="fc" id="L87">                        Entity.from(expression),</span>
<span class="fc" id="L88">                        &quot;A single Unit expression is unnecessary and can safely be removed.&quot;</span>
                    )
                )
<span class="fc" id="L91">            }</span>
<span class="fc" id="L92">        super.visitBlockExpression(expression)</span>
<span class="fc" id="L93">    }</span>

    private fun KtExpression.canBeUsedAsValue(): Boolean =
<span class="fc" id="L96">        when (this) {</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            is KtIfExpression -&gt; {</span>
<span class="fc" id="L98">                val elseExpression = `else`</span>
<span class="fc bfc" id="L99" title="All 4 branches covered.">                if (elseExpression is KtIfExpression) elseExpression.canBeUsedAsValue() else elseExpression != null</span>
            }

<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            is KtWhenExpression -&gt;</span>
<span class="pc bpc" id="L103" title="1 of 6 branches missed.">                entries.lastOrNull()?.elseKeyword != null || WhenChecker.getMissingCases(this, bindingContext).isEmpty()</span>

            else -&gt;
<span class="nc" id="L106">                true</span>
<span class="fc" id="L107">        }</span>

    private fun isExplicitApiModeActive(): Boolean {
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        val resources = compilerResources ?: return false</span>
<span class="fc" id="L111">        val flag = resources.languageVersionSettings.getFlag(AnalysisFlags.explicitApiMode)</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        return flag != ExplicitApiMode.DISABLED</span>
    }

    private fun checkFunctionWithExplicitReturnType(function: KtNamedFunction, typeReference: KtTypeReference) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        val typeElementText = typeReference.typeElement?.text</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">        if (typeElementText == UNIT) {</span>
<span class="fc" id="L118">            val initializer = function.initializer</span>
<span class="fc bfc" id="L119" title="All 6 branches covered.">            if (initializer?.isGenericOrNothingType() == true) return</span>
            // case when explicit api is on so in case of expression body we need Unit
<span class="fc bfc" id="L121" title="All 6 branches covered.">            if (initializer != null &amp;&amp; isExplicitApiModeActive() &amp;&amp; function.isPublic) return</span>
<span class="fc" id="L122">            report(CodeSmell(Entity.from(typeReference), createMessage(function)))</span>
        }
<span class="fc" id="L124">    }</span>

    private fun checkFunctionWithInferredReturnType(function: KtNamedFunction) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        val referenceExpression = function.bodyExpression as? KtNameReferenceExpression</span>
<span class="fc bfc" id="L128" title="All 4 branches covered.">        if (referenceExpression != null &amp;&amp; referenceExpression.text == UNIT) {</span>
<span class="fc" id="L129">            report(CodeSmell(Entity.from(referenceExpression), createMessage(function)))</span>
        }
<span class="fc" id="L131">    }</span>

<span class="fc" id="L133">    private fun createMessage(function: KtNamedFunction) = &quot;The function ${function.name} &quot; +</span>
<span class="fc" id="L134">        &quot;defines a return type of Unit. This is unnecessary and can safely be removed.&quot;</span>

    private fun KtExpression.isGenericOrNothingType(): Boolean {
<span class="pc bpc" id="L137" title="2 of 8 branches missed.">        val isGenericType = getResolvedCall(bindingContext)?.candidateDescriptor?.returnType?.isTypeParameter() == true</span>
<span class="pc bpc" id="L138" title="1 of 4 branches missed.">        val isNothingType = getType(bindingContext)?.isNothing() == true</span>
        // Either the function initializer returns Nothing or it is a generic function
        // into which Unit is passed, but not both.
<span class="fc bfc" id="L141" title="All 8 branches covered.">        return (isGenericType &amp;&amp; !isNothingType) || (isNothingType &amp;&amp; !isGenericType)</span>
    }

    companion object {
        private const val UNIT = &quot;Unit&quot;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202408290909</span></div></body></html>