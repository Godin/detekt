<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SleepInsteadOfDelay.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">code-coverage-report</a> &gt; <a href="index.source.html" class="el_package">io.gitlab.arturbosch.detekt.rules.coroutines</a> &gt; <span class="el_source">SleepInsteadOfDelay.kt</span></div><h1>SleepInsteadOfDelay.kt</h1><pre class="source lang-java linenums">package io.gitlab.arturbosch.detekt.rules.coroutines

import io.gitlab.arturbosch.detekt.api.ActiveByDefault
import io.gitlab.arturbosch.detekt.api.CodeSmell
import io.gitlab.arturbosch.detekt.api.Config
import io.gitlab.arturbosch.detekt.api.Entity
import io.gitlab.arturbosch.detekt.api.RequiresTypeResolution
import io.gitlab.arturbosch.detekt.api.Rule
import org.jetbrains.kotlin.builtins.isSuspendFunctionType
import org.jetbrains.kotlin.com.intellij.psi.PsiElement
import org.jetbrains.kotlin.descriptors.FunctionDescriptor
import org.jetbrains.kotlin.psi.KtCallExpression
import org.jetbrains.kotlin.psi.KtCallableReferenceExpression
import org.jetbrains.kotlin.psi.KtExpression
import org.jetbrains.kotlin.psi.KtLambdaExpression
import org.jetbrains.kotlin.psi.KtNamedFunction
import org.jetbrains.kotlin.psi.KtProperty
import org.jetbrains.kotlin.psi.KtValueArgument
import org.jetbrains.kotlin.psi.psiUtil.getParentOfType
import org.jetbrains.kotlin.psi.psiUtil.getParentOfTypes
import org.jetbrains.kotlin.psi.psiUtil.getParentOfTypesAndPredicate
import org.jetbrains.kotlin.resolve.BindingContext
import org.jetbrains.kotlin.resolve.calls.util.getParameterForArgument
import org.jetbrains.kotlin.resolve.calls.util.getResolvedCall
import org.jetbrains.kotlin.resolve.descriptorUtil.fqNameOrNull

/**
 * Report usages of `Thread.sleep` in suspending functions and coroutine blocks. A thread can
 * contain multiple coroutines at one time due to coroutines' lightweight nature, so if one
 * coroutine invokes `Thread.sleep`, it could potentially halt the execution of unrelated coroutines
 * and cause unpredictable behavior.
 *
 * &lt;noncompliant&gt;
 * suspend fun foo() {
 *     Thread.sleep(1_000L)
 * }
 * &lt;/noncompliant&gt;
 *
 * &lt;compliant&gt;
 * suspend fun foo() {
 *     delay(1_000L)
 * }
 * &lt;/compliant&gt;
 *
 */
@RequiresTypeResolution
@ActiveByDefault(since = &quot;1.21.0&quot;)
<span class="fc" id="L48">class SleepInsteadOfDelay(config: Config) : Rule(</span>
<span class="fc" id="L49">    config,</span>
<span class="fc" id="L50">    &quot;Usage of `Thread.sleep()` in coroutines can potentially halt multiple coroutines at once.&quot;</span>
) {

    override fun visitCallExpression(expression: KtCallExpression) {
<span class="fc" id="L54">        super.visitCallExpression(expression)</span>
<span class="fc" id="L55">        checkAndReport(expression)</span>
<span class="fc" id="L56">    }</span>

    override fun visitCallableReferenceExpression(expression: KtCallableReferenceExpression) {
<span class="fc" id="L59">        super.visitCallableReferenceExpression(expression)</span>
<span class="fc" id="L60">        checkAndReport(expression)</span>
<span class="fc" id="L61">    }</span>

    private fun checkAndReport(expression: KtExpression) {
<span class="fc bfc" id="L64" title="All 4 branches covered.">        if (expression.isThreadSleepFunction() &amp;&amp; shouldReport(expression)) {</span>
<span class="fc" id="L65">            report(CodeSmell(Entity.from(expression), SUSPEND_FUN_MESSAGE))</span>
        }
<span class="fc" id="L67">    }</span>

    private fun KtExpression.isThreadSleepFunction(): Boolean {
        fun KtCallableReferenceExpression.isSleepCallableRef(): Boolean =
<span class="fc bfc" id="L71" title="All 2 branches covered.">            if (this.parent is KtValueArgument) {</span>
                // Only checking if this is used as for invocation
<span class="fc" id="L73">                this.callableReference.isThreadSleepFunction()</span>
            } else {
<span class="fc" id="L75">                false</span>
<span class="fc" id="L76">            }</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        return if (this is KtCallableReferenceExpression) {</span>
<span class="fc" id="L78">            this.isSleepCallableRef()</span>
        } else {
<span class="fc" id="L80">            getResolvedCall(bindingContext)</span>
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">                ?.resultingDescriptor</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                ?.fqNameOrNull()</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">                ?.asString() == FQ_NAME</span>
        }
    }

    @Suppress(&quot;ReturnCount&quot;)
    private fun getNearestParentForSuspension(psiElement: PsiElement): PsiElement? {
        fun KtValueArgument.isNearestParentForSuspension(): Boolean {
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">            val parent = this.getParentOfTypes(true, KtCallExpression::class.java) ?: return false</span>
<span class="fc" id="L91">            val callDescriptor = parent.getResolvedCall(bindingContext)</span>
<span class="fc" id="L92">            val valueParameterDescriptor =</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">                parent.getResolvedCall(bindingContext)</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">                    ?.getParameterForArgument(this)</span>
<span class="nc" id="L95">                    ?: return false</span>
<span class="pc bpc" id="L96" title="3 of 6 branches missed.">            val functionDescriptor = callDescriptor?.resultingDescriptor as? FunctionDescriptor ?: return false</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">            return functionDescriptor.isInline.not() ||</span>
<span class="fc bfc" id="L98" title="All 4 branches covered.">                (valueParameterDescriptor.isNoinline || valueParameterDescriptor.isCrossinline)</span>
        }
<span class="fc" id="L100">        return psiElement.getParentOfTypesAndPredicate(</span>
<span class="fc" id="L101">            false,</span>
<span class="fc" id="L102">            KtNamedFunction::class.java,</span>
<span class="fc" id="L103">            KtValueArgument::class.java,</span>
<span class="fc" id="L104">            KtLambdaExpression::class.java,</span>
        ) {
<span class="fc" id="L106">            when (it) {</span>
<span class="fc bfc" id="L107" title="All 2 branches covered.">                is KtValueArgument -&gt; {</span>
<span class="fc" id="L108">                    it.isNearestParentForSuspension()</span>
                }

<span class="fc bfc" id="L111" title="All 2 branches covered.">                is KtNamedFunction -&gt; {</span>
<span class="fc" id="L112">                    true</span>
                }

<span class="pc bpc" id="L115" title="1 of 2 branches missed.">                is KtLambdaExpression -&gt; {</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">                    it.getParentOfType&lt;KtProperty&gt;(true, KtValueArgument::class.java) != null</span>
                }

                else -&gt; {
<span class="nc" id="L120">                    false</span>
                }
<span class="fc" id="L122">            }</span>
        }
    }

    private fun PsiElement.isSuspendAllowed(): Boolean =
<span class="fc" id="L127">        when (this) {</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">            is KtValueArgument -&gt; {</span>
<span class="fc" id="L129">                this.isSuspendAllowed()</span>
            }

<span class="fc bfc" id="L132" title="All 2 branches covered.">            is KtNamedFunction -&gt; {</span>
<span class="fc" id="L133">                this.isSuspendAllowed()</span>
            }

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            is KtLambdaExpression -&gt; {</span>
<span class="fc" id="L137">                this.isSuspendAllowed()</span>
            }

            else -&gt; {
<span class="nc" id="L141">                false</span>
            }
<span class="fc" id="L143">        }</span>

    private fun KtValueArgument.isSuspendAllowed(): Boolean {
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        val parent = this.getParentOfTypes(true, KtCallExpression::class.java) ?: return false</span>
<span class="fc" id="L147">        val valueParameterDescriptor =</span>
<span class="fc" id="L148">            parent.getResolvedCall(bindingContext)</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">                ?.getParameterForArgument(this)</span>
<span class="pc bpc" id="L150" title="2 of 6 branches missed.">        return valueParameterDescriptor?.returnType?.isSuspendFunctionType == true</span>
    }

    private fun KtLambdaExpression.isSuspendAllowed(): Boolean {
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">        val parent = this.getParentOfTypes(true, KtProperty::class.java)</span>
<span class="nc" id="L155">            ?: return false</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">        val properDescriptor = bindingContext[BindingContext.VARIABLE, parent] ?: return false</span>
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">        return properDescriptor.returnType?.isSuspendFunctionType ?: false</span>
    }

    private fun KtNamedFunction.isSuspendAllowed(): Boolean {
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        val functionDescriptor = bindingContext[BindingContext.FUNCTION, this] ?: return false</span>
<span class="fc" id="L162">        return functionDescriptor.isSuspend</span>
    }

    private fun shouldReport(expression: KtExpression): Boolean {
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">        val nearestParentForSuspension = getNearestParentForSuspension(expression) ?: return false</span>
<span class="fc" id="L167">        return nearestParentForSuspension.isSuspendAllowed()</span>
    }

    companion object {
        private const val SUSPEND_FUN_MESSAGE =
            &quot;This use of Thread.sleep() inside a suspend function should be replaced by delay().&quot;
        private const val FQ_NAME = &quot;java.lang.Thread.sleep&quot;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202408290909</span></div></body></html>